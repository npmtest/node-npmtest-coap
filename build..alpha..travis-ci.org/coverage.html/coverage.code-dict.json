{"/home/travis/build/npmtest/node-npmtest-coap/test.js":"/* istanbul instrument in package npmtest_coap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-coap/lib.npmtest_coap.js":"/* istanbul instrument in package npmtest_coap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_coap = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_coap = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-coap/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-coap && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_coap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_coap\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_coap.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_coap.rollup.js'] =\n            local.assetsDict['/assets.npmtest_coap.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_coap.__dirname +\n                    '/lib.npmtest_coap.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/index.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar optionsConv     = require('./lib/option_converter')\n  , Server          = require('./lib/server')\n  , Agent           = require('./lib/agent')\n  , parameters      = require('./lib/parameters')\n  , net             = require('net')\n  , URL             = require('url')\n  , globalAgent     = new Agent({ type: 'udp4' })\n  , globalAgentV6   = new Agent({ type: 'udp6' })\n\nmodule.exports.request = function(url) {\n  var agent, req, ipv6\n\n  if (typeof url === 'string')\n    url = URL.parse(url)\n\n  ipv6 = net.isIPv6(url.hostname || url.host)\n\n  if (url.agent)\n    agent = url.agent\n  else if (url.agent === false && !ipv6)\n    agent = new Agent({ type: 'udp4' })\n  else if (url.agent === false && ipv6)\n    agent = new Agent({ type: 'udp6' })\n  else if (ipv6)\n    agent = exports.globalAgentIPv6\n  else\n    agent = exports.globalAgent\n\n  return agent.request(url)\n}\n\nmodule.exports.createServer = Server\n\nmodule.exports.Agent = Agent\nmodule.exports.globalAgent = globalAgent\nmodule.exports.globalAgentIPv6 = globalAgentV6\n\nmodule.exports.registerOption = optionsConv.registerOption\nmodule.exports.registerFormat = optionsConv.registerFormat\nmodule.exports.ignoreOption = optionsConv.ignoreOption\n\nmodule.exports.parameters = parameters\nmodule.exports.updateTiming = parameters.refreshTiming\nmodule.exports.defaultTiming = parameters.defaultTiming\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/option_converter.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\n// Generic toBinary and fromBinary definitions\nvar optionToBinaryFunctions = {}\nvar optionFromBinaryFunctions = {}\n\n// list of options silently ignored\nvar ignoredOptions = {};\n\nmodule.exports.toBinary = function(name, value) {\n  if (Buffer.isBuffer(value))\n    return value\n\n  if (!optionToBinaryFunctions[name])\n    throw new Error('Unknown string to Buffer converter for option: ' + name)\n\n  return optionToBinaryFunctions[name](value)\n}\n\nmodule.exports.fromBinary = function(name, value) {\n  var convert = optionFromBinaryFunctions[name]\n\n  if (!convert)\n    return value\n\n  return convert(value)\n}\n\nvar registerOption = function(name, toBinary, fromBinary) {\n  optionFromBinaryFunctions[name] = fromBinary\n  optionToBinaryFunctions[name] = toBinary\n}\n\nmodule.exports.registerOption = registerOption\n\nvar ignoreOption = function(name) {\n  ignoredOptions[name] = true;\n}\n\nmodule.exports.ignoreOption = ignoreOption\n\nignoreOption('Cache-Control')\nignoreOption('Content-Length')\nignoreOption('Accept-Ranges')\n\nmodule.exports.isIgnored = function(name) {\n  return !!ignoredOptions[name]\n}\n\n// ETag option registration\nvar fromString = function(result) {\n  return new Buffer(result)\n}\n\nvar toString = function(value) {\n  return value.toString()\n}\n\nregisterOption('ETag', fromString, toString)\nregisterOption('Location-Path', fromString, toString)\nregisterOption('Location-Query', fromString, toString)\nregisterOption('Proxy-Uri', fromString, toString)\n\nvar fromUint = function(result) {\n  var uint = Number(result)\n  if (!isFinite(uint) || Math.floor(uint) !== uint || uint < 0) {\n    throw TypeError('Expected uint, got ' + result)\n  }\n  var parts = []\n  while (uint > 0) {\n    parts.unshift(uint % 256)\n    uint = Math.floor(uint / 256)\n  }\n  return new Buffer(parts)\n}\n\nvar toUint = function(value) {\n  var result = 0;\n  for (var i = 0; i < value.length; ++i) {\n    result = 256 * result + value[i]\n  }\n  return result\n}\n\nregisterOption('Max-Age', fromUint, toUint)\n\n// Content-Format and Accept options registration\nvar formatsString = {}\nvar formatsBinaries = {}\n\nvar registerFormat = function(name, value) {\n  var bytes;\n\n  if (value > 255) {\n    bytes = new Buffer(2);\n    bytes.writeUInt16BE(value, 0);\n  } else {\n    bytes = new Buffer([value])\n  }\n\n  formatsString[name] = bytes\n  formatsBinaries[value] = name\n}\n\nmodule.exports.registerFormat = registerFormat\n\nregisterFormat('text/plain', 0)\nregisterFormat('application/link-format', 40)\nregisterFormat('application/xml', 41)\nregisterFormat('application/octet-stream', 42)\nregisterFormat('application/exi', 47)\nregisterFormat('application/json', 50)\nregisterFormat('application/cbor', 60)\n\nvar contentFormatToBinary = function(value) {\n  var result = formatsString[value.split(';')[0]]\n  if (!result)\n    throw new Error('Unknown Content-Format: ' + value)\n\n  return result\n}\n\nvar contentFormatToString = function(value) {\n  if (value.length === 0)\n    return formatsBinaries[0]\n  \n  if (value.length === 1)\n    value = value.readUInt8(0)\n  else if (value.length === 2)\n    value = value.readUInt16BE(0)\n  else\n    throw new Error('Content-Format option is too big')\n\n  var result = formatsBinaries[value]\n\n  if (!result)\n    throw new Error('No matching format found')\n\n  return result\n}\n\nregisterOption('Content-Format', contentFormatToBinary, contentFormatToString)\nregisterOption('Accept', contentFormatToBinary, contentFormatToString)\nregisterOption('Observe', function(sequence) {\n  var buf\n\n  if (!sequence) {\n    buf = new Buffer(0)\n  } else if (sequence < 256) {\n    buf = new Buffer(1)\n    buf.writeUInt8(sequence, 0)\n  } else if (sequence >= 256 & sequence < 65535) {\n    buf = new Buffer(2)\n    buf.writeUInt16BE(sequence, 0)\n  } else {\n    // it is three bytes long\n    buf = new Buffer(3)\n    buf.writeUInt8(Math.floor(sequence / 65535), 0)\n    buf.writeUInt16BE(sequence % 65535, 1)\n  }\n\n  return buf\n}, function(buf) {\n  var result = 0\n\n  if (buf.length === 1) {\n    result = buf.readUInt8(0)\n  } else if (buf.length === 2) {\n    result = buf.readUInt16BE(0)\n  } else if (buf.length === 3) {\n    result += buf.readUInt8(0) * 65353\n    result += buf.readUInt16BE(1)\n  }\n\n  return result\n})\n\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/server.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nrequire('./polyfill')\n\nvar dgram           = require('dgram')\n  , os              = require('os')\n  , net             = require('net')\n  , util            = require('util')\n  , series          = require('fastseries')\n  , crypto          = require('crypto')\n  , events          = require('events')\n  , LRU             = require('lru-cache')\n  , parse           = require('coap-packet').parse\n  , generate        = require('coap-packet').generate\n  , IncomingMessage = require('./incoming_message')\n  , OutgoingMessage = require('./outgoing_message')\n  , ObserveStream   = require('./observe_write_stream')\n  , parameters      = require('./parameters')\n  , RetrySend       = require('./retry_send')\n  , parseBlock2     = require('./helpers').parseBlock2\n  , createBlock2    = require('./helpers').createBlock2\n  , getOption       = require('./helpers').getOption\n  , isNumeric       = require('./helpers').isNumeric\n  , isBoolean       = require('./helpers').isBoolean\n  , middlewares     = require('./middlewares')\n  , debug           = require('debug')('CoAP Server')\n\n\nfunction handleEnding(err) {\n  var request = this\n  if (err) {\n    request.server._sendError(new Buffer(err.message), request.rsinfo, request.packet)\n  }\n}\n\nfunction CoAPServer(options, listener) {\n  if (!(this instanceof CoAPServer)) {\n    return new CoAPServer(options, listener)\n  }\n\n  if (typeof options === 'function') {\n    listener = options\n    options = null\n  }\n\n  if (!options)\n    options = {}\n\n  this._options = options\n  this._proxiedRequests = {}\n\n  this._middlewares = [\n    middlewares.parseRequest\n  ]\n\n  if (options.proxy) {\n    this._middlewares.push(middlewares.proxyRequest)\n    this._middlewares.push(middlewares.handleProxyResponse)\n  }\n\n  if (!this._options.piggybackReplyMs || !isNumeric(this._options.piggybackReplyMs)) {\n    this._options.piggybackReplyMs = parameters.piggybackReplyMs\n  }\n\n  if (!isBoolean(this._options.sendAcksForNonConfirmablePackets)) {\n    this._options.sendAcksForNonConfirmablePackets = parameters.sendAcksForNonConfirmablePackets\n  }\n  this._middlewares.push(middlewares.handleServerRequest)\n\n  // Multicast settings\n  this._multicastAddress = options.multicastAddress ? options.multicastAddress : null\n  this._multicastInterface = options.multicastInterface ? options.multicastInterface : null\n\n  // We use an LRU cache for the responses to avoid\n  // DDOS problems.\n  // max packet size is 1280\n  // 32 MB / 1280 = 26214\n  // The max lifetime is roughly 200s per packet.\n  // Which gave us 131 packets/second guarantee\n  this._lru = LRU({\n      max: options.cacheSize || (32768 * 1024)\n    , length: function(n) { return n.buffer.byteLength }\n    , maxAge: (parameters.exchangeLifetime * 1000)\n    , dispose:  function(key, value) {\n                  if (value.sender)\n                    value.sender.reset()\n                }\n  })\n\n  this._series = series()\n  this._block2Cache = {}\n\n  if (listener)\n    this.on('request', listener)\n  debug('initialized');\n}\n\n\nutil.inherits(CoAPServer, events.EventEmitter)\n\nCoAPServer.prototype._sendError = function(payload, rsinfo, packet) {\n  var message = generate({\n    code: '5.00',\n    payload: payload,\n    messageId: (packet)?packet.messageId:undefined,\n    token: (packet)?packet.token:undefined\n  })\n\n  this._sock.send(message, 0, message.length, rsinfo.port)\n}\n\nfunction removeProxyOptions(packet) {\n  var cleanOptions = []\n\n  for (var i = 0; i < packet.options.length; i++) {\n    if (packet.options[i].name.toLowerCase() !== 'proxy-uri' && packet.options[i].name.toLowerCase() !== 'proxy-scheme') {\n      cleanOptions.push(packet.options[i])\n    }\n  }\n\n  packet.options = cleanOptions\n\n  return packet;\n}\n\nCoAPServer.prototype._sendProxied = function(packet, proxyUri, callback) {\n  var url = require('url').parse(proxyUri)\n    , host = url.hostname\n    , port = url.port\n    , message = generate(removeProxyOptions(packet))\n\n  this._sock.send(message, 0, message.length, port, host, callback)\n}\n\nCoAPServer.prototype._sendReverseProxied = function(packet, rsinfo, callback) {\n  var host = rsinfo.address\n    , port = rsinfo.port\n    , message = generate(packet)\n\n  this._sock.send(message, 0, message.length, port, host, callback)\n}\n\nfunction handleRequest(server) {\n  return function (msg, rsinfo) {\n    var request = {\n        raw: msg,\n        rsinfo: rsinfo,\n        server: server\n      }\n      , activeMiddlewares = []\n\n    for (var i = 0; i < server._middlewares.length; i++) {\n      activeMiddlewares.push(server._middlewares[i])\n    }\n\n    server._series(request, activeMiddlewares, request, handleEnding)\n  }\n}\n\nfunction allAddresses(type) {\n    var family = 'IPv4'\n    if (type === 'udp6') {\n        family = 'IPv6'\n    }\n    var addresses = [];\n    var interfaces = os.networkInterfaces();\n    for (var ifname in interfaces)  {\n        if (interfaces.hasOwnProperty(ifname)) {\n            interfaces[ifname].forEach(function (a) {\n                if (a.family == family) {\n                    addresses.push(a.address)\n                }\n            })\n        }\n    }\n    return addresses;\n}\n\nCoAPServer.prototype.listen = function(port, address, done) {\n  var that = this\n\n  if (port == undefined) {\n    port = parameters.coapPort\n  }\n\n  if (typeof port === 'function') {\n    done = port\n    port = parameters.coapPort\n  }\n\n  if (typeof address === 'function') {\n    done = address\n    address = null\n  }\n\n  if (this._sock) {\n    if (done)\n      done(new Error('Already listening'))\n    else\n      throw new Error('Already listening')\n\n    return this\n  }\n\n  if (address && net.isIPv6(address))\n    this._options.type = 'udp6'\n\n  if (!this._options.type)\n    this._options.type = 'udp4'\n\n  this._sock = dgram.createSocket({type: this._options.type, reuseAddr : true}, handleRequest(this))\n\n  this._sock.on('error', function(error) {\n    that.emit('error', error)\n  })\n\n  this._sock.bind(port, address || null, function () {\n    if (that._multicastAddress) {\n      that._sock.setMulticastLoopback(true)\n\n      if (that._multicastInterface) {\n        that._sock.addMembership(that._multicastAddress, that._multicastInterface)\n      } else {\n        allAddresses(that._options.type).forEach(function(interface) {\n            that._sock.addMembership(that._multicastAddress, interface)\n        })\n      }\n    }\n    if (done) done()\n  })\n  this._port = port\n  this._address = address\n\n  if (parameters.pruneTimerPeriod) {\n    // Start LRU pruning timer\n    this._lru.pruneTimer = setInterval(function () {\n      that._lru.prune()\n    }, parameters.pruneTimerPeriod*1000)\n    if (this._lru.pruneTimer.unref) {\n      this._lru.pruneTimer.unref()\n    }\n  }\n\n  return this\n}\n\nCoAPServer.prototype.close = function(done) {\n  if (done) {\n    setImmediate(done)\n  }\n\n  if (this._lru.pruneTimer) {\n    clearInterval(this._lru.pruneTimer)\n  }\n\n  if (this._sock) {\n    this._sock.close()\n    this._lru.reset()\n    this._sock = null\n    this.emit('close')\n  } else {\n    this._lru.reset()\n  }\n\n  // cancel cache entry expiry timers\n  for (var k in this._block2Cache) {\n    if (this._block2Cache.hasOwnProperty(k)) {\n      debug('clean-up cache expiry timer, key:', k)\n      clearTimeout(this._block2Cache[k].timeoutId)\n      delete this._block2Cache[k]\n    }\n  }\n\n  return this\n}\n\nfunction expiry(block2cache, k) {\n  debug('delete expired cache entry, key:', k)\n  delete block2cache[k]\n}\n\nCoAPServer.prototype._handle = function(packet, rsinfo) {\n\n  if (packet.code[0] !== '0') {\n    // According to RFC7252 Section 4.2 receiving a confirmable messages\n    // that can't be processed, should be rejected by ignoring it AND\n    // sending a reset. In this case confirmable response message would\n    // be silently ignored, which is not exactly as stated in the standard.\n    // However, sending a reset would interfere with a coap client which is\n    // re-using a socket (see pull-request #131).\n    return\n  }\n\n  var sock      = this._sock\n    , lru       = this._lru\n    , acks      = this._acks\n    , cached    = lru.peek(toKey(rsinfo.address, rsinfo.port, packet, true))\n    , Message   = OutMessage\n    , that = this\n    , request\n    , response\n\n  if (cached && !packet.ack && !packet.reset) {\n    return sock.send(cached, 0, cached.length, rsinfo.port, rsinfo.address)\n  } else if (cached && (packet.ack || packet.reset)) {\n    if (cached.response && packet.reset) {\n      cached.response.end()\n    }\n    return lru.del(toKey(rsinfo.address, rsinfo.port, packet, false))\n  }\n  else if (packet.ack || packet.reset) {\n    return // nothing to do, ignoring silently\n  }\n\n  request = new IncomingMessage(packet, rsinfo)\n\n  if (request.headers['Observe'] === 0) {\n    Message = ObserveStream\n    if (packet.code !== '0.01')\n      // it is not a GET\n      return this._sendError(new Buffer('Observe can only be present with a GET'), rsinfo)\n  }\n\n  packet.piggybackReplyMs = this._options.piggybackReplyMs;\n  response = new Message(packet, function(response, packet) {\n    var buf\n      , sender = new RetrySend(sock, rsinfo.port, rsinfo.address)\n\n    try {\n      buf = generate(packet)\n    } catch(err) {\n      return response.emit('error', err)\n    }\n\n    if (Message === OutMessage) {\n      sender.on('error', response.emit.bind(response, 'error'))\n    } else {\n      buf.response = response\n      sender.on('error', function() {\n        response.end()\n      })\n    }\n\n    var key = toKey(rsinfo.address, rsinfo.port,\n        packet, packet.ack || !packet.confirmable)\n    lru.set(key, buf)\n    buf.sender = sender\n\n    if (that._options.sendAcksForNonConfirmablePackets || packet.confirmable){\n      sender.send(buf, packet.ack || packet.reset || packet.confirmable === false)\n    } else {\n      debug('OMIT ACK PACKAGE')\n    }\n  })\n\n  request.rsinfo = rsinfo\n  response.statusCode = '2.05'\n  response._request = request._packet\n  response._cachekey = toCacheKey(rsinfo.address, rsinfo.port, packet)\n\n  var block2cache = this._block2Cache\n  //inject this function so the response can add an entry to the cache\n  response._addCacheEntry = function(key, payload) {\n    if (block2cache.hasOwnProperty(key)) {\n      debug('reuse old cache entry, key:', key)\n      clearTimeout(block2cache[key].timeoutId) // cancel old expiry timer\n      block2cache[key].payload = payload\n    } else {\n      debug('add payload to cache, key:', key)\n      block2cache[key] = {payload: payload}\n    }\n    // setup new expiry timer\n    block2cache[key].timeoutId = setTimeout(expiry, parameters.exchangeLifetime * 1000, block2cache, key)\n  }\n\n  //return cached value for blockwise requests\n  var cachedResponseSend = false\n  if (packet.token && packet.token.length > 0) {\n    // return cached value only if this request is not the first block request\n    var block2Buff = getOption(response._request.options, 'Block2')\n    var requestedBlockOption\n    if (block2Buff) {\n      requestedBlockOption = parseBlock2(block2Buff)\n    }\n    if (!requestedBlockOption) {\n      requestedBlockOption = {num: 0}\n    }\n\n    if (requestedBlockOption.num < 1) {\n      if (this._block2Cache.hasOwnProperty(response._cachekey)) {\n        debug('first block2 request, remove old entry from cache, key:', response._cachekey)\n        clearTimeout(this._block2Cache[response._cachekey].timeoutId)\n        delete this._block2Cache[response._cachekey]\n      }\n    } else {\n      debug('check if packet token is in cache, key:', response._cachekey)\n      if (this._block2Cache.hasOwnProperty(response._cachekey)) {\n        debug('found cached payload, key:', response._cachekey)\n        response.end(this._block2Cache[response._cachekey].payload)\n        cachedResponseSend = true\n      }\n    }\n  }\n\n  if (!cachedResponseSend) {\n    debug('no cached entry found, emit request to upper layer');\n    this.emit('request', request, response)\n  }\n}\n\nfunction toCacheKey(address, port, packet) {\n  if (packet.token && packet.token.length > 0) {\n    return packet.token.toString('hex') + '/' + address + ':' + port\n  }\n\n  return null\n}\n\nfunction toKey(address, port, packet, appendToken) {\n  var result = address + port + packet.messageId\n\n  if (appendToken)\n    result += packet.token.toString('hex')\n\n  return result\n}\n\n/*\nnew out message\ninherit from OutgoingMessage\nto handle cached answer and blockwise (2)\n*/\nfunction OutMessage() {\n  OutgoingMessage.apply(this, Array.prototype.slice.call(arguments));\n}\nutil.inherits(OutMessage, OutgoingMessage)\n\n// maxBlock2 is in formular 2**(i+4), and must <= 2**(6+4)\nvar maxBlock2 = Math.pow(2, Math.floor(Math.log(parameters.maxPacketSize)/Math.log(2)))\nif (maxBlock2 > Math.pow(2, (6+4)))\n  maxBlock2 = Math.pow(2, (6+4))\n\nOutMessage.prototype.end= function(payload) {\n  var that = this\n\n  var block2Buff = getOption(this._request.options, 'Block2')\n  var requestedBlockOption\n  // if we got blockwise (2) resquest\n  if (block2Buff) {\n    requestedBlockOption = parseBlock2(block2Buff)\n    // bad option\n    if (!requestedBlockOption) {\n      that.statusCode = '4.02'\n      return OutgoingMessage.prototype.end.call(that)\n    }\n  }\n\n  // if payload is suitable for ONE message, shoot it out\n  if (!payload ||\n    ((!requestedBlockOption) && (payload.length < parameters.maxPacketSize)))\n    return OutgoingMessage.prototype.end.call(this, payload)\n\n  // for the first request, block2 option may be missed\n  if (!requestedBlockOption)\n    requestedBlockOption = {\n      size: maxBlock2,\n      num: 0\n    }\n\n  // block2 size should not bigger than maxBlock2\n  if (requestedBlockOption.size > maxBlock2)\n    requestedBlockOption.size = maxBlock2\n\n  // block number should have limit\n  // 0 base counter for totalBlock, hence use floor (vs ceil)\n  var totalBlock = Math.floor(payload.length/requestedBlockOption.size)\n  var isLastBlock\n  if (requestedBlockOption.num < totalBlock)\n    isLastBlock = false\n  else if (requestedBlockOption.num == totalBlock)\n    isLastBlock = true\n  else {\n    // precondition fail, may request for out of range block\n    that.statusCode = '4.02'\n    return OutgoingMessage.prototype.end.call(that)\n  }\n\n  var block2 = createBlock2({\n    moreBlock2: isLastBlock,\n    num: requestedBlockOption.num,\n    size: requestedBlockOption.size\n  })\n  if (!block2) {\n    // this catch never be match,\n    // since we're gentleman, just handle it\n    that.statusCode = '4.02'\n    return OutgoingMessage.prototype.end.call(that)\n  }\n  this.setOption('Block2', block2)\n  this.setOption('ETag', _toETag(payload))\n\n  // cache it\n  if (this._request.token && this._request.token.length > 0) {\n    this._addCacheEntry(this._cachekey, payload)\n  }\n  OutgoingMessage.prototype.end.call(this, payload.slice((requestedBlockOption.num)*requestedBlockOption.size, (requestedBlockOption.num+1)*requestedBlockOption.size))\n};\n\n/*\ncalculate id of a payload by xor each 2-byte-block from it\nuse to generate etag\n  payload         an input buffer, represent payload need to generate id (hash)\n  id              return var, is a buffer(2)\n*/\nfunction _toETag(payload) {\n  var id = new Buffer([0,0])\n  var i = 0\n  do {\n    id[0] ^= payload[i]\n    id[1] ^= payload[i+1]\n    i += 2\n  } while (i<payload.length)\n  return id\n}\n\nmodule.exports = CoAPServer\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/polyfill.js":"exports.compareBuffers = function (buf1, buf2) {\n  if (Buffer.compare)\n    return Buffer.compare(buf1, buf2)\n  else {\n    if (buf1.length != buf2.length) return -1\n    for (var i = 0; i < buf1.length; i++) {\n      if (buf1[i] != buf2[i]) return -1\n    }\n    return 0\n  }\n}","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap-packet/index.js":"\nvar empty = new Buffer(0)\n\n  // a global index for parsing the options and the payload\n  // we can do this as the parsing is a sync operation\n  , index\n\n  // last five bits are 1\n  // 31.toString(2) => '111111'\n  , lowerCodeMask = 31\n\n  , nextMsgId = Math.floor(Math.random() * 65535)\n\n  , codes\n\ncodes = {\n    'GET': 1\n  , 'POST': 2\n  , 'PUT': 3\n  , 'DELETE': 4\n  , 'get': 1\n  , 'post': 2\n  , 'put': 3\n  , 'delete': 4\n}\n\nmodule.exports.generate = function generate(packet) {\n\n  var buffer\n    , byte\n    , pos = 0\n    , options\n    , i\n    , length\n\n  packet = fillGenDefaults(packet)\n  options = prepareOptions(packet)\n  length = calculateLength(packet, options)\n\n  if (length > 1280)\n    throw new Error('Max packet size is 1280: current is ' + length)\n\n  buffer = new Buffer(length)\n\n  // first byte\n  byte = 0\n  byte |= 1 << 6 // first two bits are version\n  byte |= confirmableAckResetMask(packet)\n  byte |= packet.token.length\n  buffer.writeUInt8(byte, pos++)\n\n  // code can be humized or not\n  if (codes[packet.code])\n    buffer.writeUInt8(codes[packet.code], pos++)\n  else\n    buffer.writeUInt8(toCode(packet.code), pos++)\n\n  // two bytes for the message id\n  buffer.writeUInt16BE(packet.messageId, pos)\n  pos += 2\n\n  // the token might be an empty buffer\n  packet.token.copy(buffer, pos)\n  pos += packet.token.length\n\n  // write the options\n  for (i = 0; i < options.length; i++) {\n    options[i].copy(buffer, pos)\n    pos += options[i].length\n  }\n\n  if (packet.code !== '0.00' && packet.payload != '') {\n\n    // payload separator\n    buffer.writeUInt8(255, pos++)\n    packet.payload.copy(buffer, pos)\n  }\n\n  return buffer\n}\n\nmodule.exports.parse = function parse(buffer) {\n  index = 4\n  parseVersion(buffer)\n\n  var result = {\n      code: parseCode(buffer)\n    , confirmable: parseConfirmable(buffer)\n    , reset: parseReset(buffer)\n    , ack: parseAck(buffer)\n    , messageId: buffer.readUInt16BE(2)\n    , token: parseToken(buffer)\n    , options: null\n    , payload: null\n  }\n\n  if (result.code !== '0.00') {\n    result.options = parseOptions(buffer)\n    result.payload = buffer.slice(index + 1)\n  } else {\n    if (buffer.length != 4)\n      throw new Error('Empty messages must be empty')\n\n    result.options = []\n    result.payload = empty\n  }\n\n  return result\n}\n\nfunction parseVersion(buffer) {\n  var version = buffer.readUInt8(0) >> 6\n\n  if (version !== 1)\n    throw new Error('Unsupported version')\n\n  return version\n}\n\nfunction parseConfirmable(buffer) {\n  return (buffer.readUInt8(0) & 48) === 0\n}\n\nfunction parseReset(buffer) {\n  // 110000 is 48\n  return (buffer.readUInt8(0) & 48) === 48\n}\n\nfunction parseAck(buffer) {\n  // 100000 is 32\n  return (buffer.readUInt8(0) & 48) === 32\n}\n\nfunction parseCode(buffer) {\n  var byte = buffer.readUInt8(1)\n    , code = '' + (byte >> 5) + '.'\n\n  byte = byte & lowerCodeMask\n\n  if (byte < 10)\n    code += '0' + byte\n  else\n    code += byte\n\n  return code\n}\n\nfunction parseToken(buffer) {\n  var length = buffer.readUInt8(0) & 15\n    , result\n\n  if (length > 8) {\n    throw new Error('Token length not allowed')\n  }\n\n  result = buffer.slice(index, index + length)\n\n  index += length\n\n  return result\n}\n\nvar numMap  = {\n    '1': 'If-Match'\n  , '3': 'Uri-Host'\n  , '4': 'ETag'\n  , '5': 'If-None-Match'\n  , '6': 'Observe'\n  , '7': 'Uri-Port'\n  , '8': 'Location-Path'\n  , '11': 'Uri-Path'\n  , '12': 'Content-Format'\n  , '14': 'Max-Age'\n  , '15': 'Uri-Query'\n  , '17': 'Accept'\n  , '20': 'Location-Query'\n  , '23': 'Block2'\n  , '27': 'Block1'\n  , '35': 'Proxy-Uri'\n  , '39': 'Proxy-Scheme'\n  , '60': 'Size1'\n}\n\nvar optionNumberToString = (function genOptionParser() {\n\n  var code = Object.keys(numMap).reduce(function(acc, key) {\n\n    acc += 'case ' + key + ':\\n'\n    acc += '  return \\'' + numMap[key] +'\\'\\n'\n\n    return acc\n  }, 'switch(number) {\\n')\n\n  code += 'default:\\n'\n  code += 'return \\'\\' + number'\n  code += '}\\n'\n\n  return new Function('number', code)\n})()\n\nfunction parseOptions(buffer) {\n\n  var byte\n    , number = 0\n    , delta\n    , length\n    , nextOption = true\n    , options = []\n    , option\n\n  while (index < buffer.length) {\n    byte = buffer.readUInt8(index)\n\n    if (byte === 255 || index > buffer.length) {\n      break\n    }\n\n    delta = byte >> 4\n    length = byte & 15\n\n    index += 1\n\n    if (delta === 13) {\n      delta = buffer.readUInt8(index) + 13\n      index += 1\n    } else if (delta === 14) {\n      delta = buffer.readUInt16BE(index) + 269\n      index += 2\n    } else if (delta === 15) {\n      throw new Error('Wrong option delta')\n    }\n\n    if (length === 13) {\n      length = buffer.readUInt8(index) + 13\n      index += 1\n    } else if (length === 14) {\n      length = buffer.readUInt16BE(index) + 269\n      index += 2\n    } else if (length === 15) {\n      throw new Error('Wrong option length')\n    }\n\n    number += delta\n\n    options.push({\n        name: optionNumberToString(number)\n      , value: buffer.slice(index, index + length)\n    })\n\n    index += length\n  }\n\n  return options\n}\n\nfunction toCode(code) {\n  var split = code.split && code.split('.')\n    , by = 0\n\n  if (split && split.length === 2) {\n    by |= parseInt(split[0]) << 5\n    by |= parseInt(split[1])\n  } else {\n\n    if (!split)\n      code = parseInt(code)\n\n    by |= (code / 100) << 5\n    by |= (code % 100)\n  }\n\n  return by\n}\n\nfunction fillGenDefaults(packet) {\n\n  if (!packet)\n    packet = {}\n\n  if (!packet.payload)\n    packet.payload = empty\n\n  if (!packet.token)\n    packet.token = empty\n\n  if (packet.token.length > 8)\n    throw new Error('Token too long')\n\n  if (!packet.code)\n    packet.code = '0.01'\n\n  if (!packet.messageId)\n    packet.messageId = nextMsgId++\n\n  if (!packet.options)\n    packet.options = []\n\n  if (nextMsgId === 65535)\n    nextMsgId = 0\n\n  if (!packet.confirmable)\n    packet.confirmable = false\n\n  if (!packet.reset)\n    packet.reset = false\n\n  if (!packet.ack)\n    packet.ack = false\n\n  return packet\n}\n\nfunction confirmableAckResetMask(packet) {\n  var result\n\n  if (packet.confirmable)\n    result = 0 << 4\n  else if (packet.ack)\n    result = 2 << 4\n  else if (packet.reset)\n    result = 3 << 4\n  else\n    result = 1 << 4 // the message is non-confirmable\n\n  return result\n}\n\nfunction calculateLength(packet, options) {\n  var length = 4 + packet.payload.length + packet.token.length\n    , i\n\n  if (packet.code !== '0.00' && packet.payload != '')\n    length += 1\n\n  for (i = 0; i < options.length; i++) {\n    length += options[i].length\n  }\n\n  return length\n}\n\nvar optionStringToNumber = (function genOptionParser() {\n\n  var code = Object.keys(numMap).reduce(function(acc, key) {\n\n    acc += 'case \\'' + numMap[key] + '\\':\\n'\n    acc += '  return \\'' + key +'\\'\\n'\n\n    return acc\n  }, 'switch(string) {\\n')\n\n  code += 'default:\\n'\n  code += 'return parseInt(string)'\n  code += '}\\n'\n\n  return new Function('string', code)\n})()\n\nvar nameMap = Object.keys(numMap).reduce(function(acc, key) {\n  acc[numMap[key]] = key\n  return acc\n}, {})\n\nfunction optionSorter(a, b) {\n  a = a.name\n  b = b.name\n\n  a = parseInt(nameMap[a] || a)\n  b = parseInt(nameMap[b] || b)\n\n  if (a < b)\n    return -1\n  if (a > b)\n    return 1\n\n  return 0\n}\n\nfunction prepareOptions(packet) {\n  var options = []\n    , total = 0\n    , delta\n    , buffer\n    , byte\n    , option\n    , i\n    , bufferSize\n    , pos\n    , value\n\n  packet.options.sort(optionSorter)\n\n  for (i = 0; i < packet.options.length; i++) {\n    pos = 0\n    option = packet.options[i].name\n    delta = optionStringToNumber(option) - total\n    value = packet.options[i].value\n\n    // max option length is 1 header, 2 ext numb, 2 ext length\n    buffer = new Buffer(value.length + 5)\n\n    byte = 0\n\n\n    if (delta <= 12) {\n      byte |= delta << 4\n    } else if (delta > 12 && delta < 269) {\n      byte |= 13 << 4\n    } else {\n      byte |= 14 << 4\n    }\n\n    if (value.length <= 12) {\n      byte |= value.length\n    } else if (value.length > 12 && value.length < 269) {\n      byte |= 13\n    } else {\n      byte |= 14\n    }\n\n    buffer.writeUInt8(byte, pos++)\n\n    if (delta > 12 && delta < 269) {\n      buffer.writeUInt8(delta - 13, pos++)\n    } else if (delta >= 269) {\n      buffer.writeUInt16BE(delta - 269, pos)\n      pos += 2\n    }\n\n    if (value.length > 12 && value.length < 269) {\n      buffer.writeUInt8(value.length - 13, pos++)\n    } else if (value.length >= 269) {\n      buffer.writeUInt16BE(value.length - 269, pos)\n      pos += 2\n    }\n\n    value.copy(buffer, pos)\n    pos += value.length\n    total += delta\n    options.push(buffer.slice(0, pos))\n  }\n\n  return options\n}\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/incoming_message.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar Readable  = require('readable-stream').Readable\n  , util      = require('util')\n  , pktToMsg  = require('./helpers').packetToMessage\n\nfunction IncomingMessage(packet, rsinfo, outSocket) {\n  Readable.call(this)\n\n  pktToMsg(this, packet)\n\n  this.rsinfo = rsinfo\n  this.outSocket = outSocket\n\n  this._packet = packet\n  this._payloadIndex = 0\n}\n\nutil.inherits(IncomingMessage, Readable)\n\nIncomingMessage.prototype._read = function(size) {\n  var end     = this._payloadIndex + size\n    , start   = this._payloadIndex\n    , payload = this._packet.payload\n    , buf     = null\n\n  if (start < payload.length)\n    buf = payload.slice(start, end)\n\n  this._payloadIndex = end\n  this.push(buf)\n}\n\nmodule.exports = IncomingMessage\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/helpers.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar toBinary    = require('./option_converter').toBinary\n  , fromBinary  = require('./option_converter').fromBinary\n  , codes       = {\n        '0.01': 'GET'\n      , '0.02': 'POST'\n      , '0.03': 'PUT'\n      , '0.04': 'DELETE'\n    }\n  , capitalize  = require('capitalize')\n  , isIgnored   = require('./option_converter').isIgnored\n\nmodule.exports.genAck = function(request) {\n  return {\n      messageId: request.messageId\n    , code: '0.00'\n    , options: []\n    , confirmable: false\n    , ack: true\n    , reset: false\n  }\n}\n\nvar optionAliases = {\n  'Content-Type': 'Content-Format',\n  'Etag': 'ETag'\n}\n\nfunction setOption(name, values) {\n  var i\n\n  name = capitalize.words(name)\n  name = optionAliases[name] || name\n\n  if (isIgnored(name)) {\n    return this\n  }\n\n  this._packet.options = this._packet.options.filter(function(option) {\n    return option.name !== name\n  })\n\n  if (!Array.isArray(values))\n    values = [values]\n\n  for (i = 0; i < values.length; i++) {\n    this._packet.options.push({\n        name: name\n      , value: toBinary(name, values[i])\n    })\n  }\n\n  return this\n}\n\nmodule.exports.addSetOption = function(klass) {\n  var proto = klass.prototype\n  proto.setOption = setOption\n  proto.setHeader = setOption\n}\n\nmodule.exports.toCode = function toCode(code) {\n  if (typeof code === 'string')\n    return code\n\n  var first  = Math.floor(code / 100)\n    , second = code - first * 100\n    , result = ''\n\n  result += first + '.'\n\n  if (second < 10)\n    result += '0'\n\n  result += second\n\n  return result\n}\n\nmodule.exports.packetToMessage = function packetToMessage(dest, packet) {\n\n  var i\n    , options = packet.options\n    , option\n    , paths   = []\n    , queries = []\n    , query   = ''\n\n  dest.payload = packet.payload\n  dest.options = packet.options\n  dest.code    = packet.code\n  dest.method  = codes[packet.code]\n  dest.headers = {}\n\n  for (i=0; i < options.length; i++) {\n    option = options[i]\n\n    if (option.name === 'Uri-Path') {\n      paths.push(option.value)\n    }\n\n    if (option.name === 'Uri-Query') {\n      queries.push(option.value)\n    }\n\n    option.value = fromBinary(option.name, option.value)\n\n    if (!Buffer.isBuffer(option.value))\n      dest.headers[option.name] = option.value\n  }\n\n  if (dest.headers['Content-Format'])\n    dest.headers['Content-Type'] = dest.headers['Content-Format']\n\n  query = queries.join('&')\n  dest.url = '/' + paths.join('/')\n  if (query) {\n    dest.url += '?' + query\n  }\n}\n\n/*\nget an option value from options\n  options     array of object, in form {name: , value}\n  name        name of the object wanted to retrive\n  return      value, or null\n*/\nmodule.exports.getOption = function getOption(options, name) {\n  for (var i in options)\n    if (options[i].name == name)\n      return options[i].value\n  return null\n}\n/*\nparse block2\n  value       block2 value buffer\n  return      object describes block2, {moreBlock2: , num: , size: }\n\nwith invalid block2 value, the function return null\n*/\nmodule.exports.parseBlock2 = function parseBlock2(block2Value) {\n  var num\n  switch (block2Value.length) {\n    case 1:\n    num = block2Value[0] >> 4\n    break\n    case 2:\n    num = (block2Value[0]*256 + block2Value[1]) >> 4\n    break\n    case 3:\n    num = (block2Value[0]*256*256 + block2Value[1]*256 + block2Value[2]) >>4\n    break\n    default:\n    // Block2 is more than 3 bytes\n    return null\n  }\n  // limit value of size is 1024 (2**(6+4))\n  if (block2Value.slice(-1)[0] == 7) {\n    // Block size is bigger than 1024\n    return null\n  }\n  return {\n    moreBlock2: (block2Value.slice(-1)[0] & (0x01<<3))? true:false,\n    num: num,\n    size: Math.pow(2, (block2Value.slice(-1)[0] & 0x07)+4)\n  }\n}\n\n/*\ncreate buffer for block2 option\n  requestedBlock      object contain block2 infor, e.g. {moreBlock2: true, num: 100, size: 32}\n  return              new Buffer, carry block2 value\n*/\nmodule.exports.createBlock2 = function createBlock2(requestedBlock) {\n  var byte\n  var szx = Math.log(requestedBlock.size)/Math.log(2) - 4\n  var m = ((requestedBlock.moreBlock2==true)?0:1)\n  var num = requestedBlock.num\n  var extraNum\n\n  byte = 0\n  byte |= szx\n  byte |= m << 3\n  byte |= (num&0xf) <<4\n\n  // total num occupy up to 5 octets\n  // num share the higher octet of first byte, and (may) take more 2 bytes for the rest 4 octets\n  if (num <= 0xf) {\n    extraNum = null\n  }\n  else if (num <=0xfff) {\n    extraNum = new Buffer([num/16])\n  }\n  else if (num <=0xfffff) {\n    extraNum = new Buffer(2)\n    extraNum.writeUInt16BE(num>>4,0)\n  }\n  else {\n    // too big block2 number\n    return null\n  }\n  return (extraNum)? Buffer.concat([extraNum, new Buffer([byte])]):new Buffer([byte])\n}\n\n/**\n * Provide a or function to use with the reduce() Array method\n */\nmodule.exports.or = function or(previous, current) {\n    return previous || current;\n}\n\n/**\n * Provide a function to detect whether an option has a particular name (for its use with filter or map).\n */\nmodule.exports.isOption = function isOption(optionName) {\n  return function(option) {\n    return option.name === optionName;\n  }\n}\n\nmodule.exports.isNumeric = function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nmodule.exports.isBoolean = function isBoolean(n) {\n  return typeof(n) === 'boolean';\n}\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/outgoing_message.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar BufferList = require('bl')\n  , util       = require('util')\n  , helpers    = require('./helpers')\n  , toCode     = helpers.toCode\n\nfunction OutgoingMessage(request, send) {\n  BufferList.call(this)\n\n  this._packet = {\n      messageId: request.messageId\n    , token: request.token\n    , options: []\n    , confirmable: false\n    , ack: false\n    , reset: false\n  }\n\n  var that = this\n\n  if (request.confirmable) {\n    // replying in piggyback\n    this._packet.ack = true\n\n    this._ackTimer = setTimeout(function() {\n\n      send(that, helpers.genAck(request))\n\n      // we are no more in piggyback\n      that._packet.confirmable = true\n      that._packet.ack = false\n\n      // we need a new messageId for the CON\n      // reply\n      delete that._packet.messageId\n\n      that._ackTimer = null\n\n    }, request.piggybackReplyMs)\n  }\n\n  this._send = send\n\n  this.statusCode = ''\n  this.code = ''\n}\n\nutil.inherits(OutgoingMessage, BufferList)\nhelpers.addSetOption(OutgoingMessage)\n\nOutgoingMessage.prototype.end = function(a, b) {\n  BufferList.prototype.end.call(this, a, b)\n\n  var packet = this._packet\n    , message\n    , that = this\n\n  packet.code = toCode(this.code || this.statusCode)\n  packet.payload = this\n  this._send(this, packet)\n\n  // easy clean up after generating the packet\n  delete this._packet.payload\n\n  if (this._ackTimer)\n    clearTimeout(this._ackTimer)\n\n  return this\n}\n\nOutgoingMessage.prototype.reset = function() {\n  BufferList.prototype.end.call(this)\n\n  var packet = this._packet\n    , message\n    , that = this\n\n  packet.code = '0.00'\n  packet.payload = ''\n  packet.reset = true;\n  packet.ack = false\n\n  this._send(this, packet)\n\n  // easy clean up after generating the packet\n  delete this._packet.payload\n\n  if (this._ackTimer)\n    clearTimeout(this._ackTimer)\n\n  return this\n}\n\nOutgoingMessage.prototype.writeHead = function(code, headers) {\n  var packet = this._packet\n  var header\n  packet.code = String(code).replace(/(^\\d[^.])/, '$1.')\n  for (header in headers) {\n    if (headers.hasOwnProperty(header)) {\n      this.setOption(header, headers[header])\n    }\n  }\n}\n\nmodule.exports = OutgoingMessage\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/observe_write_stream.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar Writable = require('readable-stream').Writable\n  , util       = require('util')\n  , helpers    = require('./helpers')\n\nfunction ObserveWriteStream(request, send) {\n  Writable.call(this)\n\n  this._packet = {\n      token: request.token\n    , messageId: request.messageId\n    , options: []\n    , confirmable: false\n    , ack: request.confirmable\n    , reset: false\n  }\n\n  this._request = request\n  this._send = send\n  this.statusCode = ''\n\n  this._counter = 0\n\n  var that = this\n  this.on('finish', function() {\n    if (that._counter === 0) { // we have sent no messages\n      that._doSend(null)\n    }\n  })\n}\n\nutil.inherits(ObserveWriteStream, Writable)\nhelpers.addSetOption(ObserveWriteStream)\n\nObserveWriteStream.prototype._write = function write(data, encoding, done) {\n  this.setOption('Observe', ++this._counter)\n\n  if (this._counter === 16777215)\n    this._counter = 1\n\n  this._doSend(data)\n\n  done()\n}\n\nObserveWriteStream.prototype._doSend = function doSend(data) {\n  var packet = this._packet\n  packet.code = this.statusCode\n  packet.payload = data\n  this._send(this, packet)\n\n  this._packet.confirmable = this._request.confirmable\n  this._packet.ack = !this._request.confirmable\n  delete this._packet.messageId\n  delete this._packet.payload\n}\n\nObserveWriteStream.prototype.reset = function reset() {\n  var packet = this._packet\n  packet.code = '0.00'\n  packet.payload = ''\n  packet.reset = true;\n  packet.ack = false\n  packet.token = new Buffer(0);\n\n  this._send(this, packet)\n\n  this._packet.confirmable = this._request.confirmable\n  delete this._packet.messageId\n  delete this._packet.payload\n}\n\nmodule.exports = ObserveWriteStream\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/parameters.js":"/*\n* Copyright (c) 2013-2015 node-coap contributors.\n*\n* node-coap is licensed under an MIT +no-false-attribs license.\n* All rights not explicitly granted in the MIT license are reserved.\n* See the included LICENSE file for more details.\n*/\n\n// CoAP parameters\nvar p = {\n  ackTimeout: 2 // seconds\n  , ackRandomFactor: 1.5\n  , maxRetransmit: 4\n\n  // MAX_LATENCY is the maximum time a datagram is expected to take\n  // from the start of its transmission to the completion of its\n  // reception.\n  , maxLatency: 100 // seconds\n  , piggybackReplyMs: 50\n  // default coap port\n  , coapPort: 5683\n  // default max packet size\n  , maxPacketSize: 1280\n  // true: always send CoAP ACK messages, even for non confirmabe packets\n  // false: only send CoAP ACK messages for confirmabe packets\n  , sendAcksForNonConfirmablePackets: true\n}\nvar defaultTiming = JSON.parse(JSON.stringify(p))\n\np.refreshTiming = function(values) {\n  for (var key in values){\n    if (p[key]) {\n      p[key] = values[key]\n    }\n  }\n\n  // MAX_TRANSMIT_SPAN is the maximum time from the first transmission\n  // of a Confirmable message to its last retransmission.\n  p.maxTransmitSpan = p.ackTimeout * ((Math.pow(2, p.maxRetransmit)) - 1) * p.ackRandomFactor\n\n  // MAX_TRANSMIT_WAIT is the maximum time from the first transmission\n  // of a Confirmable message to the time when the sender gives up on\n  // receiving an acknowledgement or reset.\n  p.maxTransmitWait = p.ackTimeout * (Math.pow(2, p.maxRetransmit + 1) - 1) * p.ackRandomFactor\n\n  // PROCESSING_DELAY is the time a node takes to turn around a\n  // Confirmable message into an acknowledgement.\n  p.processingDelay = p.ackTimeout\n\n  // MAX_RTT is the maximum round-trip time\n  p.maxRTT = 2 * p.maxLatency + p.processingDelay\n\n  //  EXCHANGE_LIFETIME is the time from starting to send a Confirmable\n  //  message to the time when an acknowledgement is no longer expected,\n  //  i.e.  message layer information about the message exchange can be\n  //  purged\n  p.exchangeLifetime = p.maxTransmitSpan + p.maxRTT\n\n  // LRU prune timer period.\n  // In order to reduce unnecessary heap usage on low-traffic servers the\n  // LRU cache is periodically pruned to remove old, expired packets. This\n  // is a fairly low-intensity task, but the period can be altered here\n  // or the timer disabled by setting the value to zero.\n  // By default the value is set to 0.5 x exchangeLifetime (~120s)\n  if (values && (typeof(values.pruneTimerPeriod)===\"number\")) {\n    p.pruneTimerPeriod = values.pruneTimerPeriod\n  } else {\n    p.pruneTimerPeriod =  (0.5 * p.exchangeLifetime)\n  }\n}\np.refreshTiming()\n\n\np.defaultTiming = function() {\n  p.refreshTiming(defaultTiming)\n}\n\nmodule.exports = p\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/retry_send.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar parameters      = require('./parameters')\n  , util            = require('util')\n  , EventEmitter    = require('events').EventEmitter\n  , parse           = require('coap-packet').parse\n\nfunction RetrySend(sock, port, host) {\n  if (!(this instanceof RetrySend))\n    return new RetrySend(port, host)\n\n  var that    = this\n\n  this._sock  = sock\n\n  this._port  = port || parameters.coapPort\n\n  this._host  = host\n\n  this._sendAttemp = 0\n  this._lastMessageId = -1\n  this._currentTime = parameters.ackTimeout * (1 + (parameters.ackRandomFactor - 1) * Math.random()) * 1000\n\n  this._bOff  = function() {\n    that._currentTime = that._currentTime * 2\n    that._send()\n  }\n}\n\nutil.inherits(RetrySend, EventEmitter)\n\nRetrySend.prototype._send = function(avoidBackoff) {\n  var that = this\n\n  this._sock.send(this._message, 0, this._message.length,\n                  this._port, this._host, function(err, bytes) {\n                    that.emit('sent', err, bytes)\n                    if (err) {\n                      that.emit('error', err)\n                    }\n                  })\n\n  var messageId = parse(this._message).messageId\n  if (messageId != this._lastMessageId) {\n    this._lastMessageId = messageId\n    this._sendAttemp = 0\n  }\n\n  if (!avoidBackoff && ++this._sendAttemp <= parameters.maxRetransmit)\n    this._bOffTimer = setTimeout(this._bOff, this._currentTime)\n\n  this.emit('sending', this._message)\n}\n\nRetrySend.prototype.send = function(message, avoidBackoff) {\n  var that = this\n    , timeout\n\n  this._message = message\n  this._send(avoidBackoff)\n\n  timeout = avoidBackoff ? parameters.maxRTT : parameters.exchangeLifetime\n  this._timer = setTimeout(function() {\n    var err  = new Error('No reply in ' + timeout + 's')\n    err.retransmitTimeout = timeout;\n    if (!avoidBackoff)\n      that.emit('error', err)\n    that.emit('timeout', err)\n  }, timeout * 1000)\n}\n\nRetrySend.prototype.reset = function() {\n  clearTimeout(this._timer)\n  clearTimeout(this._bOffTimer)\n}\n\nmodule.exports = RetrySend\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/middlewares.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar crypto          = require('crypto')\n  , parse           = require('coap-packet').parse\n  , or              = require('./helpers').or\n  , isOption        = require('./helpers').isOption\n\nfunction parseRequest(request, next) {\n  try {\n    request.packet = parse(request.raw)\n    next(null)\n  } catch (err) {\n    next(err)\n  }\n}\n\nfunction handleServerRequest(request, next) {\n  if (request.proxy) {\n    return next();\n  }\n  try {\n    request.server._handle(request.packet, request.rsinfo)\n    next(null)\n  } catch (err) {\n    next(err)\n  }\n}\n\nfunction proxyRequest(request, next) {\n  for (var i = 0; i < request.packet.options.length; i++) {\n    if (request.packet.options[i].name.toLowerCase() === 'proxy-uri') {\n      request.proxy = request.packet.options[i].value.toString()\n    }\n  }\n\n  if (request.proxy) {\n    if (request.packet.token.length === 0) {\n      request.packet.token = crypto.randomBytes(8);\n    }\n\n    request.server._proxiedRequests[request.packet.token.toString('hex')] = request\n    request.server._sendProxied(request.packet, request.proxy, next)\n  } else {\n    next(null)\n  }\n}\n\nfunction isObserve(packet) {\n  return packet.options.map(isOption('Observe')).reduce(or, false);\n}\n\nfunction handleProxyResponse(request, next) {\n  if (request.proxy) {\n    return next(null)\n  }\n\n  var originalProxiedRequest = request.server._proxiedRequests[request.packet.token.toString('hex')]\n  if ( originalProxiedRequest ) {\n    request.server._sendReverseProxied(request.packet, originalProxiedRequest.rsinfo)\n\n    if (!isObserve(request.packet))\n      delete request.server._proxiedRequests[request.packet.token.toString('hex')]\n\n    next(null)\n  } else {\n    next()\n  }\n}\n\n\nexports.parseRequest = parseRequest\nexports.handleServerRequest = handleServerRequest\nexports.proxyRequest = proxyRequest\nexports.handleProxyResponse = handleProxyResponse\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/agent.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar bl              = require('bl')\n  , util            = require('util')\n  , events          = require('events')\n  , dgram           = require('dgram')\n  , parse           = require('coap-packet').parse\n  , generate        = require('coap-packet').generate\n  , URL             = require('url')\n  , IncomingMessage = require('./incoming_message')\n  , OutgoingMessage = require('./outgoing_message')\n  , ObserveStream   = require('./observe_read_stream')\n  , optionsConv     = require('./option_converter')\n  , RetrySend       = require('./retry_send')\n  , parseBlock2     = require('./helpers').parseBlock2\n  , createBlock2    = require('./helpers').createBlock2\n  , getOption       = require('./helpers').getOption\n  , maxToken        = Math.pow(2, 32)\n  , maxMessageId    = Math.pow(2, 16)\n  , pf              = require('./polyfill')\n  , hasDNSbug       = true\n\n;(function () {\n  var major = parseInt(process.version.match(/^v([^.]+).*$/)[1])\n\n  if (major >= 4) {\n    hasDNSbug = false\n  }\n})()\n\nfunction Agent(opts) {\n  if (!(this instanceof Agent))\n    return new Agent()\n\n  if (!opts)\n    opts = {}\n\n  if (!opts.type)\n    opts.type = 'udp4'\n\n  if (opts.socket) {\n    delete opts.port\n  }\n\n  this._opts = opts\n\n  this._init(opts.socket)\n}\n\nutil.inherits(Agent, events.EventEmitter)\n\nAgent.prototype._init = function initSock(socket) {\n  if (this._sock) {\n    return\n  }\n\n  var that = this\n  this._sock = socket || dgram.createSocket(this._opts.type)\n  this._sock.on('message', function(msg, rsinfo) {\n    var packet\n      , message\n      , outSocket\n\n    try {\n      packet = parse(msg)\n    } catch(err) {\n      message = generate({ code: '5.00', payload: new Buffer('Unable to parse packet') })\n      that._sock.send(message, 0, message.length,\n                      rsinfo.port, rsinfo.address)\n      return\n    }\n\n    if (packet.code[0] === '0' && packet.code !== '0.00') {\n      // ignore this packet since it's not a response.\n      return\n    }\n\n    outSocket = that._sock.address();\n    that._handle(msg, rsinfo, outSocket)\n  })\n\n  if(this._opts.port){\n    this._sock.bind( this._opts.port );\n  };\n\n  this._sock.on('error', function(err) {\n    // we are skipping DNS errors\n    if(!hasDNSbug || err.code !== 'ENOTFOUND')\n      that.emit('error', err)\n  })\n\n  this._msgIdToReq = {}\n  this._tkToReq = {}\n\n  this._lastToken = Math.floor(Math.random() * (maxToken - 1))\n  this._lastMessageId = Math.floor(Math.random() * (maxMessageId - 1))\n\n  this._closing = false\n  this._msgInFlight = 0\n  this._requests = 0\n}\n\nAgent.prototype._cleanUp = function cleanUp() {\n  if (--this._requests !== 0)\n    return\n\n  this._closing = true\n\n  if (this._msgInFlight !== 0)\n    return\n\n  this._doClose()\n}\n\nAgent.prototype._doClose = function() {\n  for (var k in this._msgIdToReq)\n    this._msgIdToReq[k].sender.reset()\n\n  if (this._opts.socket)\n    return\n\n  this._sock.close()\n  this._sock = null\n}\n\nAgent.prototype._handle = function handle(msg, rsinfo, outSocket) {\n  var packet = parse(msg)\n    , buf\n    , response\n    , that = this\n    , req = this._msgIdToReq[packet.messageId]\n    , ackSent = function(err) {\n        if (err && req)\n          req.emit('error', err)\n\n        that._msgInFlight--\n        if (that._closing && that._msgInFlight === 0) {\n          that._doClose()\n        }\n      }\n\n  if (!req) {\n    if (packet.token.length == 4) {\n      req = this._tkToReq[packet.token.readUInt32BE(0)]\n    }\n\n    if (packet.ack && !req) {\n      // nothing to do, somehow there was\n      // a duplicate ack\n      return\n    }\n\n    if (!req) {\n      buf = generate({\n          code: '0.00'\n        , reset: true\n        , messageId: packet.messageId\n      })\n\n      this._msgInFlight++\n      this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)\n      return\n    }\n  }\n\n  if (packet.confirmable) {\n    buf = generate({\n        code: '0.00'\n      , ack: true\n      , messageId: packet.messageId\n    })\n\n    this._msgInFlight++\n    this._sock.send(buf, 0, buf.length, rsinfo.port, rsinfo.address, ackSent)\n  }\n\n  if (packet.code != '0.00' && (req._packet.token.length != packet.token.length || pf.compareBuffers(req._packet.token, packet.token) != 0)) {\n    // The tokens don't match, ignore the message since it is a malformed response\n    return\n  }\n\n  if (!packet.confirmable && !req.multicast) {\n    delete this._msgIdToReq[packet.messageId]\n  }\n\n  req.sender.reset()\n\n  if (packet.code == '0.00')\n    return\n\n  var block2Buff = getOption(packet.options, 'Block2')\n  var block2\n  // if we got blockwise (2) response\n  if (block2Buff) {\n    block2 = parseBlock2(block2Buff)\n    // check for error\n    if (!block2) {\n      req.sender.reset()\n      return req.emit('error', new Error('failed to parse block2'))\n    }\n  }\n  if (block2) {\n    // accumulate payload\n    req._totalPayload = Buffer.concat([req._totalPayload, packet.payload])\n\n    if (block2.moreBlock2) {\n      // increase message id for next request\n      delete this._msgIdToReq[req._packet.messageId]\n      req._packet.messageId = that._nextMessageId()\n      this._msgIdToReq[req._packet.messageId] = req\n\n      // next block2 request\n      var block2Val = createBlock2({\n        moreBlock2: false,\n        num: block2.num+1,\n        size: block2.size\n      })\n      if (!block2Val) {\n        req.sender.reset()\n        return req.emit('error', new Error('failed to create block2'))\n      }\n      req.setOption('Block2', block2Val)\n      req.sender.send(generate(req._packet))\n\n      return\n    }\n    else {\n      // get full payload\n      packet.payload = req._totalPayload\n      // clear the payload incase of block2\n      req._totalPayload = new Buffer(0)\n    }\n  }\n\n  if (req.response) {\n    if (req.response.append) {\n      // it is an observe request\n      // and we are already streaming\n      return req.response.append(packet)\n    } else {\n      // TODO There is a previous response but is not an ObserveStream !\n      return\n    }\n\n  }\n  else if (block2) {\n    delete that._tkToReq[req._packet.token.readUInt32BE(0)]\n  }\n  else if (!req.url.observe && packet.token.length > 0) {\n    // it is not, so delete the token\n    delete that._tkToReq[packet.token.readUInt32BE(0)]\n  }\n\n  if (req.url.observe && packet.code !== '4.04') {\n    response = new ObserveStream(packet, rsinfo, outSocket)\n    response.on('close', function() {\n      delete that._tkToReq[packet.token.readUInt32BE(0)]\n      that._cleanUp()\n    })\n  } else {\n    response = new IncomingMessage(packet, rsinfo, outSocket)\n  }\n\n  if (!req.multicast) {\n    req.response = response\n  }\n\n  req.emit('response', response)\n}\n\nAgent.prototype._nextToken = function nextToken() {\n  var buf = new Buffer(4)\n\n  if (++this._lastToken === maxToken)\n    this._lastToken = 0\n\n  buf.writeUInt32BE(this._lastToken, 0)\n\n  return buf;\n}\n\nAgent.prototype._nextMessageId = function nextToken() {\n  if (++this._lastMessageId === maxMessageId)\n    this._lastMessageId = 1\n\n  return this._lastMessageId\n}\n\nAgent.prototype.request = function request(url) {\n  this._init()\n\n  var req\n    , response\n    , options = url.options || url.headers\n    , option\n    , that = this\n    , multicastTimeout = url.multicastTimeout !== undefined ? parseInt(url.multicastTimeout) : 20000\n\n  req = new OutgoingMessage({}, function(req, packet) {\n    var buf\n\n    if (url.confirmable !== false) {\n      packet.confirmable = true\n    }\n\n    // multicast message should be forced non-confirmable\n    if (url.multicast === true) {\n      req.multicast = true\n      packet.confirmable = false\n    }\n\n    if (!(packet.ack || packet.reset)) {\n      packet.messageId = that._nextMessageId()\n      packet.token = that._nextToken()\n    }\n\n    try {\n      buf = generate(packet)\n    } catch(err) {\n      req.sender.reset()\n      return req.emit('error', err)\n    }\n\n    that._msgIdToReq[packet.messageId] = req\n    that._tkToReq[that._lastToken] = req\n\n    req.sender.send(buf, !packet.confirmable)\n  })\n\n  req.sender = new RetrySend(this._sock, url.port, url.hostname || url.host)\n\n  req.url = url\n\n  req.statusCode = url.method || 'GET'\n\n  urlPropertyToPacketOption(url, req, 'pathname', 'Uri-Path', '/')\n  urlPropertyToPacketOption(url, req, 'query', 'Uri-Query', '&')\n\n  if (options) {\n    for (option in options) {\n      if (options.hasOwnProperty(option)) {\n        req.setOption(option, options[option])\n      }\n    }\n  }\n\n  if (url.proxyUri) {\n    req.setOption('Proxy-Uri', url.proxyUri)\n  }\n\n  req.sender.on('error', req.emit.bind(req, 'error'))\n\n  req.sender.on('sending', function() {\n    that._msgInFlight++\n  })\n\n  req.sender.on('timeout', function (err) {\n    req.emit('timeout', err)\n    that.abort(req)\n  })\n\n  req.sender.on('sent', function() {\n    if (req.multicast) return;\n\n    that._msgInFlight--\n    if (that._closing && that._msgInFlight === 0) {\n      that._doClose()\n    }\n  })\n\n  // Start multicast monitoring timer in case of multicast request\n  if (url.multicast === true) {\n    req.multicastTimer = setTimeout(function() {\n      that._msgInFlight--\n      if (that._msgInFlight === 0) {\n        that._doClose()\n      }\n    }, multicastTimeout)\n  }\n\n  if (url.observe)\n    req.setOption('Observe', null)\n  else\n    req.on('response', this._cleanUp.bind(this))\n\n  this._requests++\n\n  req._totalPayload = new Buffer(0)\n\n  return req\n}\n\nAgent.prototype.abort = function (req) {\n  req.sender.removeAllListeners()\n  req.sender.reset()\n  this._cleanUp()\n  delete this._msgIdToReq[req._packet.messageId]\n  delete this._tkToReq[req._packet.token.readUInt32BE(0)]\n}\n\nfunction urlPropertyToPacketOption(url, req, property, option, separator) {\n  if (url[property])\n    req.setOption(option, url[property].normalize('NFC').split(separator)\n      .filter(function(part) { return part !== '' })\n      .map(function(part) {\n        var buf = new Buffer(Buffer.byteLength(part))\n        buf.write(part)\n        return buf\n      }))\n}\n\nmodule.exports = Agent\n","/home/travis/build/npmtest/node-npmtest-coap/node_modules/coap/lib/observe_read_stream.js":"/*\n * Copyright (c) 2013-2015 node-coap contributors.\n *\n * node-coap is licensed under an MIT +no-false-attribs license.\n * All rights not explicitly granted in the MIT license are reserved.\n * See the included LICENSE file for more details.\n */\n\nvar Readable  = require('readable-stream').Readable\n  , util      = require('util')\n  , pktToMsg  = require('./helpers').packetToMessage\n\nfunction ObserveReadStream(packet, rsinfo, outSocket) {\n  Readable.call(this, { objectMode: true })\n\n  this.rsinfo = rsinfo\n  this.outSocket = outSocket\n\n  this._lastId = 0\n  this.append(packet)\n}\n\nutil.inherits(ObserveReadStream, Readable)\n\nObserveReadStream.prototype.append = function(packet) {\n  if (!this.readable)\n    return\n\n  pktToMsg(this, packet)\n  if (this.headers['Observe'] > this._lastId) {\n    this._lastId = this.headers['Observe']\n    this.push(packet.payload)\n  }\n}\n\nObserveReadStream.prototype.close = function() {\n  this.push(null)\n  this.emit('close')\n}\n\n// nothing to do, data will be pushed from the server\nObserveReadStream.prototype._read = function() {}\n\nmodule.exports = ObserveReadStream\n"}